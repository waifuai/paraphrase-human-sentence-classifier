#!/usr/bin/env python3
"""
Model interaction module for the Human/Machine Sentence Classifier using Google GenAI SDK and OpenRouter.
"""

import os
import logging
from pathlib import Path
from typing import Optional

# New SDK import
try:
    from google import genai
except Exception as e:
    genai = None

# Optional dependency for OpenRouter HTTP client
try:
    import requests
except Exception:
    requests = None

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Configuration ---
# Allow default model names to be overridden by user home dotfiles:
#   ~/.model-gemini        -> overrides DEFAULT_GEMINI_MODEL
#   ~/.model-openrouter    -> overrides DEFAULT_OPENROUTER_MODEL
API_KEY_FILE_PATH = Path.home() / ".api-gemini"  # Path to the API key file in home directory
GEMINI_MODEL_FILE_PATH = Path.home() / ".model-gemini"

# OpenRouter configuration
OPENROUTER_API_KEY_FILE_PATH = Path.home() / ".api-openrouter"
OPENROUTER_MODEL_FILE_PATH = Path.home() / ".model-openrouter"
OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions"

# Hardcoded fallbacks if no override files are present
_DEFAULT_GEMINI_MODEL_FALLBACK = "gemini-2.5-pro"
_DEFAULT_OPENROUTER_MODEL_FALLBACK = "openrouter/horizon-beta"

# --- Global state ---
_client: Optional["genai.Client"] = None

def _read_text_file(path: Path) -> Optional[str]:
    """Read and strip text from a file path if it exists; return None on failure or empty."""
    try:
        if path.is_file():
            content = path.read_text(encoding="utf-8").strip()
            return content or None
        return None
    except Exception as e:
        logging.error(f"Failed to read text from {path}: {e}")
        return None

def _resolve_gemini_default_model() -> str:
    """Resolve default Gemini model name from ~/.model-gemini, fallback to hardcoded."""
    override = _read_text_file(GEMINI_MODEL_FILE_PATH)
    return override if override else _DEFAULT_GEMINI_MODEL_FALLBACK

def _resolve_openrouter_default_model() -> str:
    """Resolve default OpenRouter model name from ~/.model-openrouter, fallback to hardcoded."""
    override = _read_text_file(OPENROUTER_MODEL_FILE_PATH)
    return override if override else _DEFAULT_OPENROUTER_MODEL_FALLBACK

# Export resolved defaults so callers (e.g., CLI) can import them
DEFAULT_GEMINI_MODEL = _resolve_gemini_default_model()
DEFAULT_OPENROUTER_MODEL = _resolve_openrouter_default_model()

def _shared_prompt(text: str) -> str:
    """Generate the shared classification prompt used for both providers."""
    return (
        "Classify the following sentence based on whether it sounds like it was "
        "written by a human or generated by a machine like an AI paraphrase tool.\n\n"
        "Categories:\n"
        "- '1': Human-written\n"
        "- '0': Machine-generated\n\n"
        "Respond with ONLY the digit '0' or '1'. Do not include any other text, "
        "explanation, or punctuation.\n\n"
        f"Sentence: \"{text}\"\n\n"
        "Classification:"
    )

# ---------------- Gemini support ----------------

def _read_key_file() -> Optional[str]:
    """Read API key from ~/.api-gemini if present."""
    try:
        if API_KEY_FILE_PATH.is_file():
            logging.info(f"Reading API key from {API_KEY_FILE_PATH}")
            return API_KEY_FILE_PATH.read_text(encoding="utf-8").strip()
        return None
    except Exception as e:
        logging.error(f"Failed to read API key from {API_KEY_FILE_PATH}: {e}")
        return None

def _resolve_api_key() -> Optional[str]:
    """Resolve API key using env first, fallback to ~/.api-gemini.

    Behavior:
    - If an env var is set and non-empty, use it.
    - If env var is set but empty, treat as unset and fall back to file.
    - If none available, return None.
    """
    env_key = os.getenv("GEMINI_API_KEY")
    if env_key and env_key.strip():
        return env_key.strip()
    env_key = os.getenv("GOOGLE_API_KEY")
    if env_key and env_key.strip():
        return env_key.strip()
    return _read_key_file()

def _ensure_client() -> bool:
    """Initialize a singleton genai.Client."""
    global _client
    if _client is not None:
        return True
    if genai is None:
        logging.error("google-genai SDK not available. Install with: google-genai~=1.28")
        return False
    api_key = _resolve_api_key()
    if not api_key:
        # For tests that patch genai.Client, we still return False when no key
        logging.error("No API key found in GEMINI_API_KEY / GOOGLE_API_KEY or ~/.api-gemini")
        return False
    try:
        _client = genai.Client(api_key=api_key)
        logging.info("Google GenAI client initialized.")
        return True
    except Exception as e:
        logging.error(f"Failed to initialize Google GenAI client: {e}")
        _client = None
        return False

def classify_with_gemini(text: str, model_name: str = DEFAULT_GEMINI_MODEL) -> Optional[str]:
    """
    Classifies the input text as human-written ('1') or machine-generated ('0') using Gemini.
    """
    if not _ensure_client():
        return None

    prompt = _shared_prompt(text)

    try:
        # New SDK call style: client.models.generate_content(...)
        resp = _client.models.generate_content(
            model=model_name,
            contents=prompt
        )
        # Response shape differs from legacy; adapt cautiously
        # Prefer a conservative extraction path:
        generated_text = None
        try:
            # SDK may expose text directly
            if hasattr(resp, "text") and isinstance(resp.text, str):
                generated_text = resp.text.strip()
        except Exception:
            pass
        if generated_text is None:
            # Fallback to candidates[0].content.parts[0].text style if exposed
            cand = getattr(resp, "candidates", None)
            if cand and len(cand) > 0:
                content = getattr(cand[0], "content", None)
                parts = getattr(content, "parts", None)
                if parts and len(parts) > 0 and hasattr(parts[0], "text"):
                    generated_text = parts[0].text.strip()

        if not generated_text:
            logging.warning("GenAI response contained no text content.")
            return None

        if generated_text in ("0", "1"):
            return generated_text
        # Heuristic fallback identical to legacy behavior
        if "0" in generated_text and "1" not in generated_text:
            return "0"
        if "1" in generated_text and "0" not in generated_text:
            return "1"
        logging.warning(f"Unexpected output: '{generated_text}'. Expected '0' or '1'.")
        return None
    except Exception as e:
        logging.error(f"Error during GenAI API call for text '{text[:50]}...': {e}")
        return None

# ---------------- OpenRouter support ----------------

def _read_openrouter_key_file() -> Optional[str]:
    """Read OpenRouter API key from ~/.api-openrouter if present."""
    try:
        if OPENROUTER_API_KEY_FILE_PATH.is_file():
            logging.info(f"Reading OpenRouter API key from {OPENROUTER_API_KEY_FILE_PATH}")
            return OPENROUTER_API_KEY_FILE_PATH.read_text(encoding="utf-8").strip()
        return None
    except Exception as e:
        logging.error(f"Failed to read OpenRouter API key from {OPENROUTER_API_KEY_FILE_PATH}: {e}")
        return None

def _resolve_openrouter_api_key() -> Optional[str]:
    """Resolve OpenRouter API key using env first, fallback to ~/.api-openrouter.

    Behavior:
    - Use OPENROUTER_API_KEY if present and non-empty.
    - If present but empty, ignore and fall back to key file.
    """
    env_key = os.getenv("OPENROUTER_API_KEY")
    if env_key and env_key.strip():
        return env_key.strip()
    return _read_openrouter_key_file()

def classify_with_openrouter(text: str, model_name: str = DEFAULT_OPENROUTER_MODEL) -> Optional[str]:
    """
    Classify using OpenRouter chat completions API. Returns '0', '1' or None.
    """
    if requests is None:
        logging.error("requests is not available. Install it to use OpenRouter support.")
        return None

    api_key = _resolve_openrouter_api_key()
    if not api_key:
        logging.error("No OpenRouter API key found in OPENROUTER_API_KEY or ~/.api-openrouter")
        return None

    prompt = _shared_prompt(text)

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }
    payload = {
        "model": model_name,
        "messages": [
            {"role": "user", "content": prompt}
        ],
        "temperature": 0.0
    }

    try:
        resp = requests.post(OPENROUTER_API_URL, headers=headers, json=payload, timeout=60)
        if resp.status_code != 200:
            logging.error(f"OpenRouter API error {resp.status_code}: {resp.text[:200]}")
            return None
        data = resp.json()

        # Try to extract assistant message content
        generated_text = None
        choices = data.get("choices", [])
        if choices:
            msg = choices[0].get("message", {})
            generated_text = (msg.get("content") or "").strip()

        if not generated_text:
            logging.warning("OpenRouter response contained no text content.")
            return None

        if generated_text in ("0", "1"):
            return generated_text
        if "0" in generated_text and "1" not in generated_text:
            return "0"
        if "1" in generated_text and "0" not in generated_text:
            return "1"
        logging.warning(f"Unexpected OpenRouter output: '{generated_text}'. Expected '0' or '1'.")
        return None
    except Exception as e:
        logging.error(f"Error during OpenRouter API call for text '{text[:50]}...': {e}")
        return None

if __name__ == "__main__":
    print("--- Testing Providers ---")
    example = "This is a sentence written by a real person, expressing a genuine thought."
    # Gemini quick test
    if _ensure_client():
        print("Gemini test:", classify_with_gemini(example))
    else:
        print("Gemini client unavailable. Ensure GEMINI_API_KEY / GOOGLE_API_KEY or ~/.api-gemini.")
    # OpenRouter quick test
    print("OpenRouter test:", classify_with_openrouter(example))